import type { AgentSystem, Agent } from '@/types/agentSystem'

export type RenderMode = 'simple' | 'grid'

export interface ComplexityScore {
  agentCount: number
  edgeCount: number
  resourceCount: number
  density: number
  maxDepth: number
  mode: RenderMode
}

/** Thresholds for switching to grid mode */
const AGENT_THRESHOLD = 10
const EDGE_THRESHOLD = 20
const DENSITY_THRESHOLD = 2.5

/**
 * Count the number of edges that would be generated by diagramBuilder.buildEdges.
 * Mirrors the edge-building logic without creating actual Edge objects.
 */
function countEdges(system: AgentSystem): number {
  let count = 0

  // User → Orchestrator + Orchestrator → User
  count += 2

  // Inter-agent data flow
  const agentIds = new Set<string>(system.agents.map((a: Agent) => a.id))
  const seenEdges = new Set<string>()

  for (const agent of system.agents) {
    for (const input of agent.inputs) {
      const sources = input.source.split('/').map((s: string) => s.trim())
      for (const src of sources) {
        if (src.startsWith('agent-') && agentIds.has(src)) {
          const edgeKey = `${src}-to-${agent.id}-${input.name.replace(/\s+/g, '_')}`
          if (!seenEdges.has(edgeKey)) {
            seenEdges.add(edgeKey)
            count++
          }
        }
      }
    }
  }

  // Resource connections
  const FILTERED_TYPES = new Set(['memory', 'knowledge'])
  if (system.sharedResources) {
    for (const resource of system.sharedResources) {
      if (FILTERED_TYPES.has(resource.type)) continue
      count += resource.accessBy.length
    }
  }

  return count
}

/**
 * Calculate the maximum depth of the workflow from exampleFlow,
 * or estimate it from agent dependency chains.
 */
function calculateMaxDepth(system: AgentSystem): number {
  if (system.exampleFlow && system.exampleFlow.length > 0) {
    return system.exampleFlow.length
  }

  // Estimate from agent dependency chain (longest path)
  const agentMap = new Map<string, Agent>(system.agents.map((a: Agent) => [a.id, a]))
  const depths = new Map<string, number>()

  function getDepth(agentId: string, visited: Set<string>): number {
    if (depths.has(agentId)) return depths.get(agentId) as number
    if (visited.has(agentId)) return 0 // cycle guard

    const agent = agentMap.get(agentId)
    if (!agent) return 0

    visited.add(agentId)
    let maxParentDepth = 0

    for (const input of agent.inputs) {
      const sources = input.source.split('/').map((s: string) => s.trim())
      for (const src of sources) {
        if (src.startsWith('agent-') && agentMap.has(src)) {
          const parentDepth = getDepth(src, visited)
          maxParentDepth = Math.max(maxParentDepth, parentDepth)
        }
      }
    }

    visited.delete(agentId)
    const depth = maxParentDepth + 1
    depths.set(agentId, depth)
    return depth
  }

  let maxDepth = 0
  for (const agent of system.agents) {
    const depth = getDepth(agent.id, new Set<string>())
    maxDepth = Math.max(maxDepth, depth)
  }

  return maxDepth
}

/**
 * Analyze the agent system and determine whether to use simple or grid rendering mode.
 */
export function calculateComplexity(system: AgentSystem): ComplexityScore {
  const agentCount = system.agents.length
  const edgeCount = countEdges(system)
  const resourceCount = system.sharedResources
    ? system.sharedResources.filter((r) => r.type !== 'memory' && r.type !== 'knowledge').length
    : 0
  const density = agentCount > 0 ? edgeCount / agentCount : 0
  const maxDepth = calculateMaxDepth(system)

  const isComplex =
    agentCount > AGENT_THRESHOLD ||
    edgeCount > EDGE_THRESHOLD ||
    density > DENSITY_THRESHOLD

  return {
    agentCount,
    edgeCount,
    resourceCount,
    density: Math.round(density * 100) / 100,
    maxDepth,
    mode: isComplex ? 'grid' : 'simple',
  }
}
